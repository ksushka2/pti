import tkinter as tk
from tkinter import ttk, messagebox
import math

class HemmingCode:
    def __init__(self, root):
        self.root = root
        self.root.title("Построение кода Хемминга")
        
        # Разворачиваем окно на весь экран
        self.root.state('zoomed')

        # Стили
        style = ttk.Style()
        style.configure('Large.TLabel', font=('Arial', 12))
        style.configure('Large.TButton', font=('Arial', 12))
        style.configure('Large.TEntry', font=('Arial', 12))

        # Создаем основной контейнер
        main_container = ttk.Frame(root)
        main_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Левая панель для ввода данных (увеличенная)
        left_panel = ttk.Frame(main_container, width=300)  # Увеличиваем с 250 до 300
        left_panel.pack(side=tk.LEFT, fill=tk.Y, padx=10)
        left_panel.pack_propagate(False)  # Запрещаем изменение размера

        # Создаем контейнер для центральной и правой панелей
        right_container = ttk.Frame(main_container)
        right_container.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=2)

        # Настраиваем сетку для правого контейнера
        right_container.grid_rowconfigure(0, weight=1)  # Растягиваем по вертикали
        right_container.grid_columnconfigure(0, minsize=550)  # Минимальная ширина для расчетов
        right_container.grid_columnconfigure(1, minsize=650)  # Минимальная ширина для дерева

        # Центральная панель для результатов расчета
        center_panel = ttk.Frame(right_container, width=550)  # Фиксированная ширина для расчетов
        center_panel.grid(row=0, column=0, sticky='nsew', padx=2)
        center_panel.pack_propagate(False)  # Запрещаем изменение размера

        # Правая панель для дерева Хемминга
        self.tree_panel = ttk.Frame(right_container, width=650)  # Фиксированная ширина для дерева
        self.tree_panel.grid(row=0, column=1, sticky='nsew', padx=2)
        self.tree_panel.pack_propagate(False)  # Запрещаем изменение размера

        # Ввод количества букв (в левой панели)
        input_frame = ttk.Frame(left_panel)
        input_frame.pack(fill=tk.X, pady=10)
        
        ttk.Label(input_frame, text="Количество букв:", style='Large.TLabel').pack(pady=5)
        self.letters_count_entry = ttk.Entry(input_frame, font=('Arial', 12), width=8)
        self.letters_count_entry.pack(pady=5)
        
        ttk.Button(input_frame, text="Создать таблицу", 
                  command=self.create_probability_table, 
                  style='Large.TButton').pack(pady=5)

        # Фрейм для таблицы вероятностей (в левой панели)
        self.prob_frame = ttk.Frame(left_panel)
        self.prob_frame.pack(fill=tk.BOTH, expand=True)

        # Текстовое поле с прокруткой для вывода результатов (в центральной панели)
        ttk.Label(center_panel, text="Результаты расчета:", style='Large.TLabel').pack(pady=5)
        
        # Создаем фрейм для текста с прокруткой
        calc_frame = ttk.Frame(center_panel)
        calc_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Добавляем вертикальный и горизонтальный скроллбары
        calc_v_scroll = ttk.Scrollbar(calc_frame)
        calc_h_scroll = ttk.Scrollbar(calc_frame, orient='horizontal')
        self.result_text = tk.Text(calc_frame, font=('Arial', 12),
                                  wrap=tk.NONE,  # Отключаем перенос строк
                                  xscrollcommand=calc_h_scroll.set,
                                  yscrollcommand=calc_v_scroll.set)
        
        # Размещаем элементы
        calc_v_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        calc_h_scroll.pack(side=tk.BOTTOM, fill=tk.X)
        self.result_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Привязываем скроллбары
        calc_v_scroll.config(command=self.result_text.yview)
        calc_h_scroll.config(command=self.result_text.xview)

        # Добавляем фрейм для канваса и скроллбаров (в правой панели)
        ttk.Label(self.tree_panel, text="Дерево Хемминга", style='Large.TLabel').pack(pady=5)
        
        self.tree_frame = ttk.Frame(self.tree_panel)
        self.tree_frame.pack(fill=tk.BOTH, expand=True)

        # Создаем канвас со скроллбарами
        self.tree_canvas = tk.Canvas(self.tree_frame, bg='white')
        v_scrollbar = ttk.Scrollbar(self.tree_frame, orient="vertical", 
                                   command=self.tree_canvas.yview)
        h_scrollbar = ttk.Scrollbar(self.tree_frame, orient="horizontal", 
                                   command=self.tree_canvas.xview)
        
        # Конфигурируем скроллбары
        self.tree_canvas.configure(yscrollcommand=v_scrollbar.set, 
                                 xscrollcommand=h_scrollbar.set)
        
        # Размещаем элементы
        h_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        v_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.tree_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    def create_probability_table(self):
        try:
            # Очищаем предыдущую таблицу
            for widget in self.prob_frame.winfo_children():
                widget.destroy()

            n = int(self.letters_count_entry.get())
            if n < 2:
                messagebox.showerror("Ошибка", "Количество букв должно быть не менее 2")
                return

            # Создаем заголовки таблицы
            ttk.Label(self.prob_frame, text="Буква", style='Large.TLabel').grid(row=0, column=0, padx=5, pady=5)
            ttk.Label(self.prob_frame, text="Вероятность", style='Large.TLabel').grid(row=0, column=1, padx=5, pady=5)

            # Создаем поля ввода для вероятностей
            self.prob_entries = []
            for i in range(n):
                ttk.Label(self.prob_frame, text=f"z{i+1}", style='Large.TLabel').grid(row=i+1, column=0, padx=5, pady=5)
                entry = ttk.Entry(self.prob_frame, font=('Arial', 12), width=10)
                entry.grid(row=i+1, column=1, padx=5, pady=5)
                self.prob_entries.append(entry)

            # Кнопка для расчета
            ttk.Button(self.prob_frame, text="Рассчитать", command=self.calculate_hemming,
                      style='Large.TButton').grid(row=n+1, column=0, columnspan=2, pady=10)

        except ValueError:
            messagebox.showerror("Ошибка", "Введите корректное число букв")

    def draw_tree(self, probabilities, nodes):
        """Рисует дерево Хемминга вертикально с кодированием букв"""
        self.tree_canvas.delete("all")  # Очищаем канвас
        
        # Размеры для дерева
        node_radius = 25
        horizontal_spacing = 120  # Расстояние между узлами по горизонтали
        vertical_spacing = 80    # Расстояние между уровнями по вертикали
        
        # Вычисляем необходимые размеры канваса
        total_width = (len(probabilities) * horizontal_spacing) + 100
        total_height = (len(nodes) * vertical_spacing) + 100
        
        # Устанавливаем размер области прокрутки
        self.tree_canvas.configure(scrollregion=(0, 0, total_width, total_height))
        
        # Словарь для хранения кодов букв
        codes = {}
        
        def draw_node(x, y, value, is_leaf=False, label=""):
            # Рисуем узел
            self.tree_canvas.create_oval(x-node_radius, y-node_radius, 
                                       x+node_radius, y+node_radius, 
                                       fill='white')
            # Добавляем значение вероятности
            self.tree_canvas.create_text(x, y-10, 
                                       text=f"{value:.4f}")
            if is_leaf:
                # Добавляем метку буквы для листьев
                self.tree_canvas.create_text(x, y+10, 
                                           text=label)

        def draw_edge(x1, y1, x2, y2, label):
            # Рисуем линию
            self.tree_canvas.create_line(x1, y1, x2, y2)
            # Добавляем метку ребра (0 или 1)
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2 - 10
            self.tree_canvas.create_text(mid_x + 15, mid_y, 
                                       text=str(label))

        def build_tree(node_list, depth, x, y, code=""):
            if len(node_list) == 1:
                # Это лист
                label = f"z{len(codes) + 1}"
                codes[label] = code
                draw_node(x, y, node_list[0], True, label)
                return

            # Берем две последние вероятности
            min_prob = node_list[-1]  # Минимальная вероятность
            max_prob = node_list[-2]  # Максимальная из двух последних

            # Рисуем текущий узел с суммой вероятностей
            current_sum = sum(node_list)
            draw_node(x, y, current_sum)

            # Вычисляем координаты для дочерних узлов
            next_y = y + vertical_spacing
            
            if len(node_list) == 2:
                left_x = x - horizontal_spacing
                right_x = x + horizontal_spacing
            else:
                # Для более чем двух узлов увеличиваем расстояние
                left_x = x - horizontal_spacing * (len(node_list) / 4)
                right_x = x + horizontal_spacing * (len(node_list) / 4)

            # Рисуем ребра с метками
            draw_edge(x, y + node_radius, left_x, next_y - node_radius, 0)
            draw_edge(x, y + node_radius, right_x, next_y - node_radius, 1)

            # Рекурсивно строим поддеревья
            if len(node_list) == 2:
                build_tree([min_prob], depth + 1, left_x, next_y, code + "0")
                build_tree([max_prob], depth + 1, right_x, next_y, code + "1")
            else:
                build_tree([min_prob], depth + 1, left_x, next_y, code + "0")
                build_tree(node_list[:-1], depth + 1, right_x, next_y, code + "1")

        # Начинаем построение дерева
        root_x = total_width / 2
        root_y = vertical_spacing
        build_tree(probabilities, 0, root_x, root_y)

        # Выводим коды букв в текстовое поле
        self.result_text.insert(tk.END, "\nПолученные коды букв:\n")
        for label, code in sorted(codes.items()):
            self.result_text.insert(tk.END, f"{label}: {code}\n")

    def calculate_hemming(self):
        try:
            # Получаем вероятности
            probabilities = []
            for entry in self.prob_entries:
                prob = float(entry.get())
                if prob <= 0 or prob > 1:
                    raise ValueError("Вероятность должна быть в диапазоне (0, 1]")
                probabilities.append(prob)

            # Проверяем сумму вероятностей
            if abs(sum(probabilities) - 1) > 0.0001:
                messagebox.showerror("Ошибка", "Сумма вероятностей должна быть равна 1")
                return

            # Сортируем вероятности по убыванию
            probabilities.sort(reverse=True)
            
            # Очищаем текстовое поле
            self.result_text.delete(1.0, tk.END)
            
            # Выводим исходные данные
            self.result_text.insert(tk.END, "Шаг 1: Исходные вероятности (по убыванию):\n")
            for i, prob in enumerate(probabilities):
                self.result_text.insert(tk.END, f"z{i+1}: {prob:.4f}\n")
            self.result_text.insert(tk.END, "\nПостроение дерева Хемминга:\n")

            # Сохраняем все уровни дерева для визуализации
            tree_nodes = [probabilities.copy()]
            current_probs = probabilities.copy()
            level = 2  # Начинаем с шага 2
            
            while len(current_probs) > 1:
                # Описание текущего шага
                self.result_text.insert(tk.END, f"\nШаг {level}:\n")
                self.result_text.insert(tk.END, f"1. Текущие вероятности: {', '.join([f'{p:.4f}' for p in current_probs])}\n")
                
                # Объединяем две последние вероятности
                last_two = current_probs[-2:]
                combined_prob = sum(last_two)
                
                self.result_text.insert(tk.END, 
                    f"2. Объединяем две наименьшие вероятности: {last_two[0]:.4f} + {last_two[1]:.4f}\n"
                    f"3. Получаем вспомогательную вероятность: {combined_prob:.4f}\n"
                )
                
                # Обновляем список вероятностей
                current_probs = current_probs[:-2] + [combined_prob]
                current_probs.sort(reverse=True)
                
                self.result_text.insert(tk.END, 
                    f"4. Сортируем вероятности по убыванию\n"
                    f"5. Новый список вероятностей: {', '.join([f'{p:.4f}' for p in current_probs])}\n"
                    f"{'=' * 50}\n"
                )
                
                tree_nodes.append(current_probs.copy())
                level += 1
                
            # Рисуем дерево
            self.draw_tree(probabilities, tree_nodes)
            
            # Добавляем итоговый результат
            self.result_text.insert(tk.END, 
                f"\nИтоговый результат:\n"
                f"Построено дерево Хемминга с {level-2} уровнями\n"
                f"Финальная вероятность: {current_probs[0]:.4f}\n"
            )
            
        except ValueError as e:
            messagebox.showerror("Ошибка", str(e))
        except Exception as e:
            messagebox.showerror("Ошибка", f"Произошла ошибка: {str(e)}")

if __name__ == "__main__":
    root = tk.Tk()
    app = HemmingCode(root)
    root.mainloop()
